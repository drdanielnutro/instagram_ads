# Revisão do Plano de Fallback — Storybrand

## 1. Sumário Executivo
- A proposta de inserir o `StoryBrandQualityGate` logo após o `landing_page_analyzer`, reutilizando `PlanningOrRunSynth` e o limiar centralizado em `config.min_storybrand_completeness`, está alinhada à arquitetura atual do pipeline e mantém o fluxo existente sem quebrar contratos de estado.【F:aprimoramento_plano_storybrand_v2.md†L11-L25】【F:app/agent.py†L1221-L1228】【F:app/config.py†L48-L55】
- O compilador já implementado em `app/agents/fallback_compiler.py` cobre o mapeamento 16→7 descrito no plano, garantindo que o caminho fallback entregue as mesmas chaves consumidas pelos agentes posteriores (briefing e execução).【F:aprimoramento_plano_storybrand_v2.md†L29-L37】【F:app/agents/fallback_compiler.py†L89-L232】【F:app/agent.py†L705-L713】
- Riscos principais: (1) o plano referencia `config.ENABLE_NEW_INPUT_FIELDS`, atributo inexistente — hoje o backend lê essa flag diretamente de variáveis de ambiente — o que impediria o gate de respeitar o rollout real; (2) o plano exige um `preflight_meta` com status `enriched/failed`, mas o preflight atual não expõe essa estrutura ao `initial_state`, tornando a checagem impraticável sem ajustes explícitos; (3) o documento ainda traz um caminho de arquivo absoluto desatualizado, dificultando rastreabilidade.【F:aprimoramento_plano_storybrand_v2.md†L22-L55】【F:app/config.py†L34-L71】【F:app/server.py†L220-L312】【F:helpers/user_extract_data.py†L412-L567】【F:aprimoramento_plano_storybrand_v2.md†L2-L55】

## 2. Itens Corretos e Consistentes
- **Gate posicionado após o analisador reutilizando o limiar global** — O plano orienta inserir o `StoryBrandQualityGate` logo após `landing_page_analyzer`, delegando ao `PlanningOrRunSynth` quando o score for suficiente e lendo o threshold de `config.min_storybrand_completeness`. Isso preserva o fluxo atual (`input → análise → planejamento/execução`) e reaproveita o mesmo parâmetro já usado pela análise original.【F:aprimoramento_plano_storybrand_v2.md†L11-L25】【F:app/agent.py†L626-L687】【F:app/agent.py†L1221-L1228】【F:app/config.py†L48-L55】
  - Evidências no código: `complete_pipeline` já instancia `PlanningOrRunSynth` após o analisador, e a configuração centraliza `min_storybrand_completeness`.
- **Contrato de estado compartilhado entre caminhos feliz e fallback** — A exigência de manter `storybrand_analysis`, `storybrand_summary` e `storybrand_ad_context` em ambos os caminhos está coberta pelo compilador atual, que persiste essas chaves e sincroniza o score no `landing_page_context`, exatamente como o plano determina.【F:aprimoramento_plano_storybrand_v2.md†L7-L9】【F:aprimoramento_plano_storybrand_v2.md†L88-L100】【F:app/agents/fallback_compiler.py†L210-L232】
  - Evidências no código: o compilador instancia `StoryBrandAnalysis`, atualiza `landing_page_context['storybrand_completeness']` e mantém a compatibilidade com o schema Pydantic.
- **Lista das 16 seções e prompts dedicados** — O plano define as mesmas chaves esperadas pelo compilador (`storybrand_character`, `exposition_1`, etc.) e reforça a necessidade de prompts específicos por seção, o que garante coerência com a lógica já implementada e facilita reutilizar os nomes que o compilador conhece.【F:aprimoramento_plano_storybrand_v2.md†L57-L77】【F:app/agents/fallback_compiler.py†L89-L206】
  - Evidências no código: o compilador consome exatamente essas chaves ao montar os elementos do StoryBrand.
- **Pré-condições de coleta de inputs essenciais compatíveis com frontend e preflight** — O plano exige que `nome_empresa`, `o_que_a_empresa_faz` e `sexo_cliente_alvo` estejam presentes na raiz do estado. O wizard do frontend e o `UserInputExtractor` já validam esses campos quando as flags estão ativas, e o checklist registra as tarefas relacionadas, demonstrando viabilidade do requisito.【F:aprimoramento_plano_storybrand_v2.md†L80-L87】【F:frontend/src/constants/wizard.constants.ts†L15-L136】【F:helpers/user_extract_data.py†L412-L567】【F:checklist.md†L40-L43】
  - Evidências no código: validações obrigatórias no wizard, normalização e rejeição de `sexo_cliente_alvo` inválido no preflight, além de itens do checklist alinhados a essa coleta.

## 3. Inconsistências Encontradas
- **Uso de `config.ENABLE_NEW_INPUT_FIELDS` inexistente** — O plano determina que o gate só deve permitir fallback quando `config.ENABLE_NEW_INPUT_FIELDS` estiver `True`. A configuração atual não possui esse atributo; o backend lê `ENABLE_NEW_INPUT_FIELDS` diretamente das variáveis de ambiente tanto no preflight quanto no servidor. Sem correção, o gate lançaria `AttributeError` ou ignoraria o rollout real.【F:aprimoramento_plano_storybrand_v2.md†L22-L26】【F:aprimoramento_plano_storybrand_v2.md†L201-L203】【F:app/config.py†L34-L71】【F:app/server.py†L220-L312】
  - Impacto: impediria o controle de rollout combinado com o frontend, fazendo o fallback rodar em ambientes onde os campos ainda são opcionais ou falhando por exceção.
  - Evidências no código: ausência do atributo no dataclass de configuração e leitura da flag diretamente via `os.getenv` no endpoint e no extractor.
  - Relação com ADK: o gate executaria antes do restante do pipeline; um erro aqui interrompe a sessão ADK inteira.
  - **Correção Sugerida**: atualizar o plano para que o gate leia `ENABLE_NEW_INPUT_FIELDS` do mesmo lugar que o backend (`os.getenv`) ou para que a própria etapa de configuração adicione explicitamente `enable_new_input_fields` ao dataclass antes de usá-lo.

- **Dependência de `state['preflight_meta']` sem fonte de dados** — O plano impõe que o preflight marque `state['preflight_meta']['o_que_a_empresa_faz'] = 'enriched'` e que o coletor cheque esse status antes de prosseguir. O helper atual não retorna `preflight_meta`, e o endpoint `/run_preflight` rejeita requisições com campos inválidos retornando HTTP 422, sem montar `initial_state`. Portanto, não há caminho para essa flag chegar ao ADK hoje.【F:aprimoramento_plano_storybrand_v2.md†L50-L55】【F:helpers/user_extract_data.py†L412-L567】【F:app/server.py†L150-L312】
  - Impacto: o coletor ficaria aguardando metadados inexistentes, podendo abortar erroneamente ou exigir alterações não especificadas no backend.
  - Evidências no código: `initial_state` inclui apenas os campos já validados e não carrega metadados extras; o helper não produz `preflight_meta`.
  - Relação com ADK: a ausência desse status quebraria a lógica de gate/collector desenhada para o fallback.
  - **Correção Sugerida**: instruir o plano a aproveitar os dados já disponíveis (`normalized`, `errors`) ou a ampliar explicitamente o `initial_state`/preflight para incluir `preflight_meta`, com passos claros de implementação no backend.

- **Caminho de arquivo absoluto desatualizado** — A seção introdutória continua apontando para `/Users/institutorecriare/.../plano_storybrand_fallback.md`, enquanto o documento reside na raiz do repositório como `aprimoramento_plano_storybrand_v2.md`. Manter o path antigo dificulta localizar a fonte oficial do plano durante execuções reais do checklist.【F:aprimoramento_plano_storybrand_v2.md†L1-L2】
  - Impacto: risco de confundir colaboradores sobre qual arquivo seguir durante incidentes de fallback.
  - Evidências no código/repo: o arquivo versionado encontra-se na raiz do projeto com o novo nome.
  - Relação com ADK: documentação equivocada pode levar a execuções fora do plano esperado em retomadas manuais.
  - **Correção Sugerida**: atualizar o cabeçalho para usar o caminho relativo correto (`aprimoramento_plano_storybrand_v2.md`) ou referenciar o repositório remoto.

## 4. Pontos de Incerteza
- O plano não descreve como proceder quando `VITE_ENABLE_NEW_FIELDS` estiver ativa no frontend, mas `ENABLE_NEW_INPUT_FIELDS` permanecer desativada no backend (ou vice-versa); falta definir a política de sincronização de flags para evitar abortos indevidos do fallback.【F:aprimoramento_plano_storybrand_v2.md†L80-L87】【F:app/server.py†L220-L305】
- Não há clareza sobre quem consumirá `state['storybrand_recovery_report']` gerado pelo `fallback_quality_reporter` opcional (logs locais, dashboard ou outra API).【F:aprimoramento_plano_storybrand_v2.md†L42-L49】
- A convenção de prompts (`prompts/storybrand_fallback/`) ainda não existe no repositório; é necessário definir owners e validações para garantir que o loader sugerido não falhe por arquivos ausentes.【F:aprimoramento_plano_storybrand_v2.md†L57-L77】

## 5. Viabilidade de Implementação (por tema)
- **Integração do gate (Seções 2–3)** — Viável. O pipeline já expõe `PlanningOrRunSynth` e o limiar configurável; basta criar o agente customizado e inserir a lógica de roteamento, desde que o plano atualize a forma de ler as flags de rollout.【F:aprimoramento_plano_storybrand_v2.md†L11-L27】【F:app/agent.py†L626-L713】【F:app/config.py†L48-L55】
- **Pipeline fallback (Seções 4–7)** — Estruturalmente exequível com `SequentialAgent`/`LoopAgent`, mas depende de corrigir a origem dos metadados (inputs essenciais e prompts) para que o coletor e o runner não travem por dados ausentes.【F:aprimoramento_plano_storybrand_v2.md†L39-L77】【F:app/server.py†L220-L312】【F:helpers/user_extract_data.py†L412-L567】
- **Coleta e flags (Seção 8 e 16.3)** — Parcialmente viável. O frontend e o preflight já validam os campos quando as flags estão ativas, porém o plano precisa alinhar-se ao mecanismo real de configuração (`os.getenv`) antes que o gate faça a checagem condicional.【F:aprimoramento_plano_storybrand_v2.md†L80-L203】【F:frontend/src/constants/wizard.constants.ts†L15-L136】【F:app/server.py†L220-L305】
- **Contrato pós-fallback e observabilidade (Seções 9–13 e 16)** — Viável: o compilador já entrega o contrato esperado, e o checklist cobre os artefatos de documentação/testes. Restará implementar logs e testes adicionais conforme descrito.【F:aprimoramento_plano_storybrand_v2.md†L88-L194】【F:app/agents/fallback_compiler.py†L210-L232】【F:checklist.md†L1-L81】
- **Feature flags e rollout (Seção 14)** — Viável após ajustar o tratamento das flags no `config` ou no gate; a criação de `ENABLE_STORYBRAND_FALLBACK` segue o padrão utilizado pelas demais variáveis do projeto.【F:aprimoramento_plano_storybrand_v2.md†L138-L139】【F:app/config.py†L34-L71】
