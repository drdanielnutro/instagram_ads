# Revisão crítica do "Plano de Validação Determinística do JSON Final de Ads"

## 1. Inconsistências e Premissas Incorretas (ordem de gravidade)

1. **Coerência CTA × `objetivo_final` indefinida**
   - **Justificativa:** o plano determina que o `FinalDeliveryValidatorAgent` reprove combinações "incoerentes" de CTA usando as especificações existentes.【F:plano_validacao_json.md†L45-L55】 Entretanto, `FORMAT_SPECS` só publica `cta_preferencial` para `agendamentos`, `leads` e `vendas`; não há mapa para objetivos que o prompt e o pipeline aceitam como `contato` ou variantes semelhantes.【F:app/format_specifications.py†L14-L59】【F:app/agent.py†L1030-L1071】 Com essa lacuna, qualquer anúncio legítimo com `objetivo_final="contato"` – já previsto no prompt do `final_fix_agent` – seria marcado como inválido mesmo escolhendo um CTA permitido pelo enum global do pipeline.
   - **Sugestão de correção:** alinhar o plano para que a validação use listas explícitas por objetivo (incluindo `contato`, `awareness` etc.) ou, na ausência do mapeamento completo, adotar fallback que aceite qualquer CTA presente no enum global até que o inventário seja ampliado.

2. **Responsabilidades sobrepostas do `FinalAssemblyGuard`**
   - **Justificativa:** a fase 4.3.1 manda o guard atuar antes do LLM bloqueando ausência de `VISUAL_DRAFT`, enquanto a 4.3.2 diz que "após a resposta LLM" o mesmo guard fará pós-processamento e sobrescreverá `state["final_code_delivery"]` com a versão validada.【F:plano_validacao_json.md†L60-L115】 O código atual registra snippets aprovados via callback (`collect_code_snippets_callback`) e somente o `final_assembler` (com callback próprio de persistência) manipula `final_code_delivery` após a chamada LLM.【F:app/agent.py†L122-L136】【F:app/agent.py†L1023-L1050】 Sem um wrapper adicional ou divisão em dois agentes, o guard não consegue executar antes *e* depois do `final_assembler_llm`, deixando indefinido como o pós-processamento seria disparado.
   - **Sugestão de correção:** detalhar a topologia — por exemplo, criar dois agentes (`FinalAssemblyGuardPre`/`Post`) ou encapsular o LLM em um `SequentialAgent` onde o guard tenha callbacks distintos — deixando explícito como o estado será atualizado em cada estágio.

3. **Remoção implícita do `EscalationBarrier`**
   - **Justificativa:** o pipeline proposto substitui o trecho atual por `RunIfPassed`, omitindo o `EscalationBarrier` que hoje envolve o `final_validation_loop` e impede que eventos `escalate=True` terminem a sequência prematuramente.【F:plano_validacao_json.md†L60-L110】【F:app/agent.py†L1240-L1268】 No código vigente, o `FeatureOrchestrator` depende das flags `final_validation_result_failed` para avisar o cliente, e o barrier garante que mesmo com `EscalationChecker` o loop conclua e propague essas flags em vez de abortar a cadeia com um evento de escalada.【F:app/agent.py†L1245-L1325】 Sem definir um substituto, corremos risco de interromper o pipeline antes que `make_failure_handler` marque o estado.
   - **Sugestão de correção:** manter explicitamente um `EscalationBarrier` (mesmo aninhado ao `RunIfPassed`) ou documentar um mecanismo equivalente que consuma o sinal de escalada e preserve a compatibilidade com `FeatureOrchestrator`.

4. **Persistência pós-imagens sem condição de falha**
   - **Justificativa:** o plano promete que o novo `persist_final_delivery_agent` salvará o JSON "mesmo quando o `image_assets_agent` for pulado ou falhar", mas a orquestração mostrada aciona o persistente apenas se `semantic_visual_review` estiver com `grade="pass"` — não há checagem do resultado do agente de imagens.【F:plano_validacao_json.md†L60-L129】 Hoje, o próprio `ImageAssetsAgent` serializa e grava `final_code_delivery` e já chama `persist_final_delivery`, registrando também `state["image_assets"]` com erros detalhados por variação.【F:app/agent.py†L310-L583】 Se movermos a persistência sem replicar essa lógica (ex.: verificar `image_assets` ou exceções da geração), perderemos o ponto de decisão que sabe se houve falha parcial/total e qual payload deve ser salvo.
   - **Sugestão de correção:** especificar no plano como o novo agente lerá `state["image_assets"]`/`final_delivery_status` para decidir entre persistir com imagens, sem imagens ou abortar, e quais flags adicionais desbloquearão a execução quando o estágio de imagens for omitido.

5. **Uso de `force_storybrand_fallback` como único relaxamento**
   - **Justificativa:** a flexibilização do schema está condicionada apenas a `state["force_storybrand_fallback"]` estar `True`.【F:plano_validacao_json.md†L33-L56】 No entanto, o `StoryBrandQualityGate` ativa o fallback também quando o score está abaixo do threshold ou ausente, mesmo sem setar essa flag, e o pipeline de landing page ainda pode marcar `force_storybrand_fallback` em callbacks de erro específicos (ex.: falha Vertex).【F:app/agents/storybrand_gate.py†L31-L86】【F:app/callbacks/landing_page_callbacks.py†L21-L61】 Nessas rotas legítimas, o validador não relaxaria os campos e rejeitaria entregas produzidas pelo fallback parcial.
   - **Sugestão de correção:** mapear explicitamente todas as condições de fallback (score baixo, score ausente, debug flag, erros de ferramenta) e alinhar o schema para aceitá-las — por exemplo, checando `state["storybrand_gate_metrics"]` ou um indicador de pipeline efetivamente executado em fallback.


## 2. Lacunas de Requisitos ou Detalhamento

- **Recuperação determinística de `VISUAL_DRAFT`** – O plano pressupõe que `FinalAssemblyGuard` consiga localizar snippets aprovados, mas não descreve como distinguir categorias dentro de `approved_code_snippets` (lista de dicionários serializados pelo callback). Precisamos definir filtro, parsing e comportamento em caso de múltiplas versões.【F:plano_validacao_json.md†L60-L115】【F:app/agent.py†L1005-L1039】【F:app/agent.py†L125-L136】
- **Atualização de consumidores (`FeatureOrchestrator`, endpoints)** – A diretriz fala em observar `final_delivery_validation_failed`, porém o código atual sinaliza `final_validation_result_failed` e renderiza mensagens específicas. Falta plano para migrar mensagens, SSE e metadados (`final_delivery_status`).【F:plano_validacao_json.md†L100-L129】【F:app/agent.py†L1286-L1325】【F:app/callbacks/persist_outputs.py†L18-L98】
- **Integração com `write_failure_meta`** – A proposta cita o helper, mas não determina quando e com quais cargas extras o validador determinístico deve gravar/limpar a sidecar de falha. Hoje isso acontece em callbacks de landing page e persistência; sem esse detalhamento, o endpoint `/delivery/final/meta` pode retornar sucesso mesmo após um `fail` determinístico.【F:plano_validacao_json.md†L45-L129】【F:app/callbacks/landing_page_callbacks.py†L12-L63】【F:app/utils/delivery_status.py†L8-L76】
- **Testes de integração** – A estratégia propõe simular `final_assembler → validador`, mas não descreve como mockar `LlmAgent`s nem como validar a interação com `RunIfPassed`/`EscalationBarrier`. Sem fixtures de estado + fake agents, os testes ficam inviáveis no ADK atual.【F:plano_validacao_json.md†L134-L167】【F:app/agent.py†L1230-L1267】

## 3. Impactos não considerados / Riscos residuais

- **StoryBrand fallback forçado** – Alterar o fluxo de validação pode interagir com `storybrand_gate_metrics` e com o caminho "landing page pulada". Precisamos confirmar se a ausência de `landing_page_context` (quando o fallback é forçado antes do fetch) será aceita pelo novo schema ou sinalizada como erro recuperável.【F:plano_validacao_json.md†L33-L56】【F:app/agents/storybrand_gate.py†L29-L102】【F:app/callbacks/landing_page_callbacks.py†L12-L63】 *(risco residual: comportamento depende do schema definitivo).*  
- **Atualização do arquivo persistido** – Hoje `ImageAssetsAgent` regrava o JSON com links de imagem antes de chamar `persist_final_delivery`. Ao mover a persistência para outro agente é preciso garantir que o `state["final_code_delivery"]` já contenha os assets serializados (string) e que o novo agente respeite a lógica de upload/GCS existente.【F:plano_validacao_json.md†L60-L129】【F:app/agent.py†L310-L583】【F:app/callbacks/persist_outputs.py†L18-L98】 *(risco residual: execução incorreta pode gerar artefatos sem imagens).*  
- **Duplicação de payload normalizado** – Armazenar `normalized_payload` dentro de `final_delivery_validation` além de atualizar `state["final_code_delivery"]` duplica a estrutura (~3 variações) no estado; avaliar impacto de memória e serialização SSE.【F:plano_validacao_json.md†L45-L55】【F:app/agent.py†L1230-L1267】 *(risco residual: potencial aumento de payload transmitido aos clientes SSE).*

## 4. Pontos que exigem esclarecimento antes da implementação

- **Fluxo completo de callbacks/falhas** – Precisamos de diagrama ou tabela indicando em quais condições cada estágio chama `append_delivery_audit_event`, `write_failure_meta`, `clear_failure_meta` e quais chaves (`final_delivery_validation_failed`, `semantic_visual_review_failed`) ficam disponíveis para o frontend.【F:plano_validacao_json.md†L45-L129】【F:app/utils/delivery_status.py†L8-L76】
- **Contrato do `semantic_visual_reviewer`** – O plano apenas afirma que reutilizará `Feedback`. É necessário definir prompts, saídas esperadas e como o `semantic_fix_agent` saberá diferenciar falhas de narrativa versus problemas estruturais já tratados pelo determinístico.【F:plano_validacao_json.md†L60-L129】【F:app/agent.py†L1240-L1267】
- **Comportamento do `RunIfPassed` em estado ausente** – Especificar se a ausência do review (ex.: validador falhou antes de criar `semantic_visual_review`) deve ser tratada como `fail` silencioso e se haverá logging/audit dedicado.【F:plano_validacao_json.md†L60-L129】

---

**Resumo:** antes de codificar, é crucial alinhar as regras determinísticas às capacidades atuais (CTA × objetivo), definir a arquitetura do guard/pipeline pós-LMM e esclarecer a gestão de falhas/persistência. Sem isso, corremos o risco de reprovar casos legítimos, quebrar o fluxo do ADK ou gerar entregas inconsistentes.
