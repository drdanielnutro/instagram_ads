# Revisão crítica do plano `plano_validacao_json.md` (branch `creative-spark`, commit e58b4c1)

## Thinking
- Revisei novamente o plano original e o pipeline atual (agentes, callbacks e estrutura de estado) para garantir que cada solução proposta mantenha compatibilidade com o rollout progressivo.
- Validei dependências cruzadas entre agentes (`final_assembler`, `final_validation_loop`, `image_assets_agent`, `FeatureOrchestrator`) e o fluxo StoryBrand para evitar regressões em callbacks e persistência.
- Para cada inconsistência apontada anteriormente, defini ajustes incrementais que possam ser aplicados em etapas, sempre prevendo fallback e rollback seguros.

## 1. Consistência entre o plano e o pipeline ADK atual
- **Guards no assembler exigem campos inexistentes.** O plano pressupõe que `approved_code_snippets` possua `snippet_type` e `status` para que o `FinalAssemblyGuardPre` filtre apenas VISUAL_DRAFT aprovados.【F:plano_validacao_json.md†L68-L71】 Na prática, os snippets armazenados pelo callback só trazem `task_id`, `category`, `file_path` e `code`, sem status ou identificadores adicionais, o que inviabiliza a triagem proposta e exige estender o coletor antes dos guards.【F:app/agent.py†L122-L136】
- **`RunIfPassed` não existe hoje no ADK.** O plano encadeia `RunIfPassed` em vários pontos do pipeline determinístico,【F:plano_validacao_json.md†L73-L118】【F:plano_validacao_json.md†L143-L149】 porém só há uma implementação de `RunIfFailed` no código atual.【F:app/agent.py†L240-L262】 Isso implica criar um novo agente utilitário (ou outra estratégia de gating) antes de executar os passos seguintes.
- **Sequência sugerida conflita com callbacks vigentes.** O `final_assembler` é hoje um `LlmAgent` com `after_agent_callback=persist_final_delivery`, e o `ImageAssetsAgent` também chama `persist_final_delivery` ao anexar imagens.【F:app/agent.py†L1023-L1050】【F:app/agent.py†L520-L576】 O plano manda remover esses callbacks quando a flag estiver ativa,【F:plano_validacao_json.md†L135-L156】 mas não detalha como substituir a persistência no caminho legado nem como garantir que a função não seja executada duas vezes quando a flag alternar. Será preciso refatorar a criação dos agentes (dois pipelines distintos ou callbacks condicionais) para manter compatibilidade.
- **Reaproveitamento do snippet aprovado após o LLM está pouco especificado.** O plano quer que o `FinalAssemblyNormalizer` reescreva `state["final_code_delivery"]` reaproveitando o VISUAL_DRAFT aprovado.【F:plano_validacao_json.md†L68-L118】【F:plano_validacao_json.md†L138-L142】 Hoje o `final_assembler` gera o JSON diretamente e não há armazenamento estruturado do snippet aprovado além da versão textual no array.【F:app/agent.py†L1023-L1046】【F:app/agent.py†L122-L136】 Falta definir como mapear o snippet para cada variação e como lidar com múltiplos VISUAL_DRAFT aprovados.
- **Conversão do `final_validation_loop` para revisão semântica exige redirecionar callbacks.** O loop atual grava falha em `final_validation_result_failed` via `make_failure_handler`, e o `FeatureOrchestrator` já observa esse campo para sinalizar erros ao usuário.【F:app/agent.py†L1240-L1266】【F:app/agent.py†L1286-L1311】 O plano prevê novas chaves (`final_delivery_validation_failed`, `semantic_visual_review_failed`), mas não cobre a remoção/renomeação da flag antiga, nem explica como manter compatibilidade durante o rollout.

### Soluções
1. **Enriquecer `approved_code_snippets` antes dos guards.** Atualizar o callback que popula `approved_code_snippets` para anexar `snippet_id`, `snippet_type`, `status` e `approved_at`. Fonte: estender `append_visual_draft_snippet` em `app/agent.py` e armazenar o hash do conteúdo como `snippet_id`. Com isso, os guards filtram VISUAL_DRAFT aprovados sem quebrar consumidores existentes (o shape atual permanece um superset).
2. **Introduzir utilitário `RunIfPassed` reutilizável.** Implementar agente wrapper em `app/agents/gating.py` seguindo o padrão de `RunIfFailed`, executando o filho apenas quando `state[check_key] is not True`. Ajustar o plano para citá-lo explicitamente ou encapsular a lógica no `EscalationBarrier` com callback de aprovação.
3. **Refatorar persistência com fábrica de agentes.** Criar função `build_final_assembler(config)` que receba a flag e injete `after_agent_callbacks` apropriados. Na versão determinística, mover a persistência para um novo `PersistFinalDeliveryAgent` após o guard; na versão legada, manter o callback original. Isso evita chamadas duplicadas ao alternar a flag.
4. **Normalizar reuso do VISUAL_DRAFT aprovado.** Persistir os snippets aprovados em `state['approved_visual_drafts']` (mapa `variation_id -> snippet`) durante o guard, permitindo que o `FinalAssemblyNormalizer` reconstrua `final_code_delivery`. Documentar que múltiplos VISUAL_DRAFT devem ser mesclados por `variation_id`; em caso de duplicidade, escolher o último aprovado e logar alerta.
5. **Manter compatibilidade das flags de falha.** Até que todos os consumidores leiam `final_delivery_validation_failed`, registrar os dois campos (`final_validation_result_failed` e a nova chave) no `final_validation_loop`. Planejar limpeza coordenada na fase final do rollout.

## 2. Cobertura e riscos da flag `ENABLE_DETERMINISTIC_FINAL_VALIDATION`
- **Criação condicional do pipeline ocorre em tempo de importação.** O plano demonstra um `if config.enable_deterministic_final_validation:` envolvendo a montagem do `execution_pipeline`.【F:plano_validacao_json.md†L65-L133】 Como `app/agent.py` instancia os agentes na importação, mudar a flag em runtime (ex.: ajustar env e reiniciar) exige reinstanciar o módulo. O plano deveria explicitar que a flag será lida apenas na inicialização do processo e que alternar requer reload para evitar estados inconsistentes.
- **Rollback parcial não está descrito.** Se a flag for reverter para `False` após ter executado o novo fluxo, o estado pode manter chaves novas (`final_delivery_validation`, `semantic_visual_review`) que os consumidores legados não reconhecem. O plano não define limpeza/compatibilidade dessas chaves ao desativar a flag ou ao persistir entregas usando o fluxo antigo.
- **Persistência e callbacks durante o rollout.** Ao desativar a flag, o plano manda “manter os callbacks atuais”,【F:plano_validacao_json.md†L135-L156】 porém, uma vez que eles tenham sido removidos do `LlmAgent` para a versão com flag habilitada, será necessário recriá-los ao alternar. Recomenda-se documentar passos explícitos para reinstanciar o `final_assembler` com/sem callback ou introduzir wrappers configuráveis em vez de alterar o agente original.

### Soluções
1. **Inicialização única por processo.** Documentar que a flag é avaliada em `build_execution_pipeline()` e registrar o valor carregado no boot (`log_config_flag('enable_deterministic_final_validation', value)`) para evitar expectativas de alternância dinâmica.
2. **Rollback controlado.** Introduzir helper `reset_deterministic_validation_state(state)` executado antes de reutilizar o pipeline legado, removendo chaves específicas (`final_delivery_validation`, `semantic_visual_review`, `approved_visual_drafts`) e garantindo compatibilidade com consumidores antigos.
3. **Callbacks configuráveis via fábrica.** Centralizar a criação dos agentes finais em `build_final_delivery_stage(flag_enabled: bool)` que injeta ou omite `persist_final_delivery`. Assim, alternar a flag requer apenas reiniciar o processo, sem mutar agentes em runtime.

## 3. Reuso de dados StoryBrand e impacto no fallback
- **Condição `storybrand_audit_trail.fallback_triggered` inexistente.** O plano sugere afrouxar o schema quando `state.get("storybrand_audit_trail", {}).get("fallback_triggered")` for verdade.【F:plano_validacao_json.md†L33-L36】 Contudo, `storybrand_audit_trail` é hoje uma lista de eventos, sem campo de resumo ou chave `fallback_triggered`, o que impossibilita a checagem proposta.【F:app/agents/storybrand_fallback.py†L52-L98】 Será preciso alterar a estrutura do audit trail ou usar outro indicador (como `storybrand_gate_metrics.decision_path`).
- **`landing_page_context.error` não é padrão.** O estado da landing page é populado com dados estruturados, mas não há convenção para uma chave `error`; o callback apenas garante que o dicionário exista.【F:app/agent.py†L688-L713】 Depender desse campo pode gerar falsos positivos de relaxamento do schema. Melhor definir um flag explícito (`landing_page_analysis_failed`) e documentado.
- **Relaxamento de `contexto_landing` precisa garantir compatibilidade.** O plano quer aceitar tanto `str` quanto `dict` e liberar campos vazios em fallback,【F:plano_validacao_json.md†L33-L36】 mas o JSON atual (montado pelo assembler) espera `contexto_landing` string.【F:app/agent.py†L1032-L1040】 Qualquer flexibilização deve vir acompanhada de normalização posterior para não quebrar consumidores.

### Soluções
1. **Consolidar metadados do StoryBrand.** Gerar `state['storybrand_fallback_meta']` a partir do `StoryBrandQualityGate`, contendo `decision_path`, `trigger_reason` e `fallback_engaged: bool`, e atualizar o plano para usar essa chave ao relaxar o schema.
2. **Flag explícito para erros de landing page.** Fazer com que o analisador de landing page grave `landing_page_analysis_failed: bool` sempre que gerar saída incompleta, evitando depender de campos ausentes.
3. **Normalização pós-relaxamento.** Adicionar transformação no `FinalAssemblyNormalizer` que aceita `contexto_landing` como string ou dicionário, convertendo dicionários em string JSON canônica e mantendo compatibilidade com consumidores externos.

## 4. Alinhamento com agentes existentes e callbacks
- **Compatibilidade do `final_assembler` com novos guards.** O assembler atual depende dos snippets já coletados e grava o resultado com callback. Introduzir um `SequentialAgent` composto exigirá remover o `final_assembler` original do `execution_pipeline` e atualizar referências (inclusive testes) que importam o agente único.【F:app/agent.py†L1023-L1266】 O plano deve esclarecer se o novo estágio substituirá o objeto existente ou se criará um wrapper reutilizando-o.
- **`image_assets_agent` hoje executa mesmo após falha.** Sem `RunIfPassed`, o agente roda mesmo se o `final_validation_loop` reprovar, e ele próprio tenta persistir o JSON (com ou sem imagens).【F:app/agent.py†L520-L576】【F:app/agent.py†L1240-L1266】 O plano precisa detalhar como impedir a execução quando o review determinístico reprovar e como sincronizar o relatório `image_assets`/`image_assets_review` para manter compatibilidade com `write_failure_meta`.
- **`FeatureOrchestrator` e status reporter requerem múltiplas atualizações.** Hoje, o orquestrador só verifica `final_validation_result_failed` para sinalizar erro final.【F:app/agent.py†L1286-L1311】 O plano solicita novas chaves de estado,【F:plano_validacao_json.md†L135-L158】 mas não define mensagens, prioridades nem limpeza dessas flags após sucesso/rollback. Falta especificar os contratos esperados por SSE, APIs e consumidores que leem `final_delivery_status`.

### Soluções
1. **Wrapper determinístico para o assembler.** Criar `DeterministicFinalAssembler` (SequentialAgent) que encapsula o assembler legado, adicionando guards/normalizers conforme a flag. Referências externas continuam usando a mesma interface.
2. **Gate para `image_assets_agent`.** Posicionar `RunIfPassed` antes do agente de imagens avaliando `final_delivery_validation_failed`. Em caso de reprovação, registrar metadados com `write_failure_meta` e pular anexos.
3. **Atualização do `FeatureOrchestrator`.** Expandir o mapeamento de status para ler `final_validation_result_failed`, `final_delivery_validation_failed` e `semantic_visual_review_failed`, priorizando mensagens determinísticas e limpando as chaves ao concluir com sucesso ou ao executar rollback.

## 5. Testes e observabilidade
- **Cobertura unitária carece de casos negativos adicionais.** Embora o plano liste vários cenários para o validador,【F:plano_validacao_json.md†L163-L191】 ele não aborda validações de reutilização do snippet VISUAL_DRAFT nem o comportamento quando o parsing inicial falha ou quando `final_code_delivery` chega como lista de strings (caso comum em falhas do assembler). Recomenda-se acrescentar testes para normalização, deduplicação e logs/audit trail.
- **Integrações devem simular ambos pipelines completos.** Os testes de integração propostos cobrem `force_storybrand_fallback` e a flag,【F:plano_validacao_json.md†L192-L199】 mas não mencionam cenários com flag desativada após habilitação (rollback) nem verificam se `persist_final_delivery` é invocado exatamente uma vez. Incluir asserts sobre callbacks e geração de meta ajudará a prevenir regressões.
- **Observabilidade nova precisa mapear métricas/logs.** O plano fala em `append_delivery_audit_event` em todas as etapas,【F:plano_validacao_json.md†L154-L158】 porém não define campos mínimos, severidades ou integrações com métricas existentes (`record_storybrand_fallback`, Cloud Logging). Documentar os novos eventos/labels é essencial para monitorar a migração gradual.

### Soluções
1. **Unitários específicos do normalizador.** Adicionar testes cobrindo reuso do VISUAL_DRAFT, conversão de `contexto_landing` e deduplicação de variações, incluindo casos em que `final_code_delivery` chega como lista de strings.
2. **Integrações de ida e volta da flag.** Escrever cenários que habilitam a flag, verificam execução completa (com `persist_final_delivery` único) e depois desabilitam a flag confirmando rollback limpo e limpeza de chaves.
3. **Observabilidade com contrato explícito.** Definir esquema para `append_delivery_audit_event` (`stage`, `status`, `detail`, `storybrand_fallback_engaged`) e registrar métricas correlacionadas em dashboards existentes para monitorar os dois pipelines.

## Recomendações gerais
1. Atualizar o plano especificando ajustes na estrutura de `approved_code_snippets` (ou propor fonte alternativa) antes de introduzir guards que dependem de `status`/`snippet_id`.
2. Descrever a implementação de `RunIfPassed` (ou alternativa) e como ela interage com `EscalationBarrier` e `LoopAgent` para evitar duplicidade de eventos.
3. Incluir estratégia explícita de rollback para a flag, abordando reinstanciação de agentes, limpeza de chaves de estado e compatibilidade com callbacks existentes.
4. Revisar o mecanismo de relaxamento do schema em fallback, alinhando-se aos campos reais disponíveis no estado (`storybrand_gate_metrics`, auditoria como lista) e evitando suposições sobre erros da landing page.
5. Expandir a seção de testes/observabilidade para cobrir persistência condicionada, novos eventos de audit trail e monitoração dos dois caminhos do pipeline durante a migração.
